{"relevantArticles":[{"articleTitle":"Spring Security","articleAbstractText":"依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifact....","articleStatus":0,"articlePermalink":"/articles/2021/02/03/1612338859541.html","articleImg1URL":"https://b3logfile.com/bing/20200513.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Spring注解驱动开发之AOP","articleAbstractText":"AOP指在程序运行期间动态地将某段代码切入到指定位置进行运行的编程方式 -- 动态代理 简单使用 步骤： 1.导入AOP模块：Spring AOP -- spring-aspects 2.定义一个业务逻辑类，运行期间打印日志 3.定义一个日志切面类 通知方法： （1）前置通知(@Before)：在目标方法运行之前运行 （2）后置通知(@After)：在目标方法运行之后运行（无论方法正常结束还是异常结束） （3）返回通知(@AfterReturning)：在目标方法正常返回之后运行 （4）异常通知(@AfterThrowing)：在目标方法出现异常以后运行 （5）环绕通知(@Around)：动态代理，手动推进目标方法就行 4.给切面类的目标方法标注何时何地运行（通知注解） 5.将切面类和业务逻辑类都加入到容器中 6.告诉Spring哪个类是切面类 -- 给切面类加上 @Aspect 注解 7.开启AspectJAutoProxy -- 在配置类加上 @EnableAspectJAutoProxy 注解 //配置类 @Configuration @EnableAspectJAutoProx....","articleStatus":0,"articlePermalink":"/articles/2020/10/20/1603206892093.html","articleImg1URL":"https://b3logfile.com/file/2020/10/image-5b300cac.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"Spring注解驱动开发之声明式事务","articleAbstractText":"简单使用 1.导入相关依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2.配置数据源、JdbcTemplate（Spring提供的简化数据库操作工具） @Bean public DataSource dataSource() throws PropertyVetoException { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setUser(\"root\"); dataSource.setPassword(\"458974tl\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/test?useSSL=f.....","articleStatus":0,"articlePermalink":"/articles/2020/10/22/1603377269375.html","articleImg1URL":"https://b3logfile.com/bing/20180912.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Spring Boot2","articleAbstractText":"01、Spring与SpringBoot 1、Spring能做什么 1.1、Spring的能力 1.2、Spring的生态 https://spring.io/projects/spring-boot 覆盖了： web开发 数据访问 安全控制 分布式 消息服务 移动开发 批处理 ...... 1.3、Spring5重大升级 1.3.1、响应式编程 1.3.2、内部源码设计 基于Java8的一些新特性，如：接口默认实现。重新设计源码架构。 2、为什么用SpringBoot Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can \"just run\". 能快速创建出生产级别的Spring应用 2.1、SpringBoot优点 Create stand-alone Spring applications 创建独立Spring应用 Embed Tomcat, Jetty or Undertow directly (no n....","articleStatus":0,"articlePermalink":"/articles/2021/02/04/1612396619399.html","articleImg1URL":"https://b3logfile.com/file/2021/02/solofetchupload1620669083251881989-76e62460.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"Spring注解驱动开发拓展","articleAbstractText":"BeanFactoryPostProcessor BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后调用，所有的Bean定义已经保存加载到BeanFactory，但是Bean的实例还未创建 执行时机： （1）IOC创建容器对象 （2）invokeBeanFactoryPostProcessors(beanFactory) -- 执行BeanFactoryProcessor 如何找到所有的BeanFactoryProcessor？ 直接在BeanFactory中找到所有类型是BeanFactoryPostProcessor的组件，并执行他们的方法 在初始化创建其他组件之前执行 @Component public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor { public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableLi......","articleStatus":0,"articlePermalink":"/articles/2020/10/25/1603583704409.html","articleImg1URL":"https://b3logfile.com/bing/20190422.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}