{"relevantArticles":[{"articleTitle":"Spring注解驱动开发之声明式事务","articleAbstractText":"简单使用 1.导入相关依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2.配置数据源、JdbcTemplate（Spring提供的简化数据库操作工具） @Bean public DataSource dataSource() throws PropertyVetoException { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setUser(\"root\"); dataSource.setPassword(\"458974tl\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/test?useSSL=f.....","articleStatus":0,"articlePermalink":"/articles/2020/10/22/1603377269375.html","articleImg1URL":"https://b3logfile.com/bing/20180912.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"常见排序算法","articleAbstractText":"冒泡排序 冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。 这个算法的名字由来是因为越小的元素会经由交换慢慢\u201c浮\u201d到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名\u201c冒泡排序\u201d。 原理： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 public static int[] BubbleSort(int[] arr) { for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j.......","articleStatus":0,"articlePermalink":"/articles/2020/03/29/1585496316027.html","articleImg1URL":"https://img.hacpai.com/file/2020/03/20150811164218318-02c3fe14.gif?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Spring Security","articleAbstractText":"依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifact....","articleStatus":0,"articlePermalink":"/articles/2021/02/03/1612338859541.html","articleImg1URL":"https://b3logfile.com/bing/20200513.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Spring注解驱动开发拓展","articleAbstractText":"BeanFactoryPostProcessor BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后调用，所有的Bean定义已经保存加载到BeanFactory，但是Bean的实例还未创建 执行时机： （1）IOC创建容器对象 （2）invokeBeanFactoryPostProcessors(beanFactory) -- 执行BeanFactoryProcessor 如何找到所有的BeanFactoryProcessor？ 直接在BeanFactory中找到所有类型是BeanFactoryPostProcessor的组件，并执行他们的方法 在初始化创建其他组件之前执行 @Component public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor { public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableLi......","articleStatus":0,"articlePermalink":"/articles/2020/10/25/1603583704409.html","articleImg1URL":"https://b3logfile.com/bing/20190422.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Spring Boot之配置","articleAbstractText":"配置文件 SpringBoot 使用一个全局的配置文件，配置文件名是固定的；用来修改SpringBoot自动配置的默认值 application.properties 跟 yml 文件类似，二者选择其一使用 person.age=20 #map的配置形式，每个键值对分开配置 person.map.k1=v1 person.map.k2=v2 #list的配置形式，每个元素用逗号隔开 person.list=a,b,c #对象的配置形式，对象中的每个属性分开赋值 person.dog.name=dog person.dog.age=10 application.yml YAML（YAML Ain't Markup Language) 标记语言： 以前的配置文件大多都是 XML 文件 YAML：以数据为中心，比 JSON、XML 等更适合做配置文件 server: port: 8081 基本语法 k: v：表示一对键值对（值前面必须有一个空格），以空格的缩进来控制层级关系，只要是左对齐的一列数据都是同一个层级的 server: port: 8081 path: /hello 属性和值.......","articleStatus":0,"articlePermalink":"/articles/2020/11/20/1605886055349.html","articleImg1URL":"https://b3logfile.com/bing/20200714.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}