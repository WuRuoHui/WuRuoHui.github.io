<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="theme-color" content="#3b3e43"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no"/><title>Spring Boot与Web - WuRuoHui 的个人博客</title><meta name="description" content="1、简介 使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx xxxxAutoConfiguration：帮我们给容器中自动配置组件； xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则； @ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false) public class ResourceProperties implements ResourceLoaderAware { //可以设置和静态资源有关的参数，缓存时间等 WebMvcAuotConfiguration： @Override public void addResourceHandlers(Res...."/><meta property="og:description" content="1、简介 使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx xxxxAutoConfiguration：帮我们给容器中自动配置组件； xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则； @ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false) public class ResourceProperties implements ResourceLoaderAware { //可以设置和静态资源有关的参数，缓存时间等 WebMvcAuotConfiguration： @Override public void addResourceHandlers(Res...."/>    <meta name="keywords" content="Solo,Java,博客,开源"/><link rel="dns-prefetch" href="https://wuruohui.github.io"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://wuruohui.github.io"><link rel="icon" type="image/png" href="https://b3log.org/images/brand/solo-128.png"/><link rel="apple-touch-icon" href="https://b3log.org/images/brand/solo-128.png"><link rel="shortcut icon" type="image/x-icon" href="https://b3log.org/images/brand/solo-128.png"><meta name="copyright" content="B3log"/><meta http-equiv="Window-target" content="_top"/><meta property="og:locale" content="zh_CN"/><meta property="og:title" content="Spring Boot与Web - WuRuoHui 的个人博客"/><meta property="og:site_name" content="WuRuoHui 的个人博客"/><meta property="og:url"      content="https://wuruohui.github.io/articles/2020/11/26/1606349708094.html?"/><meta property="og:image" content="https://b3log.org/images/brand/solo-128.png"/><link rel="search" type="application/opensearchdescription+xml" title="Spring Boot与Web - WuRuoHui 的个人博客" href="/opensearch.xml"><link href="https://wuruohui.github.io/rss.xml" title="RSS" type="application/rss+xml" rel="alternate"/><link rel="manifest" href="https://wuruohui.github.io/manifest.json">        <link rel="canonical" href="https://wuruohui.github.io/articles/2020/11/26/1606349708094.html">        <link rel="stylesheet"
              href="https://wuruohui.github.io/skins/Pinghsu/css/base.css?1613894294256"/>
            <link rel="prev" title="Spring Boot与日志" href="https://wuruohui.github.io/articles/2020/11/23/1606090789595.html">
            <link rel="next" title="Spring Boot与数据访问" href="https://wuruohui.github.io/articles/2020/12/06/1607214139317.html">
    <script src="https://cdn.jsdelivr.net/npm/vditor@3.6.6/dist/js/icons/ant.js" async="" id="vditorIconScript"></script></head>
<body>
<header class="header">
    <div class="wrapper">
        <a href="https://wuruohui.github.io" rel="start" class="header__logo">
            <img src="https://img.hacpai.com/avatar/1583717982177_1583772537638.jpeg?imageView2/1/w/128/h/128/interlace/0/q/100" alt="WuRuoHui 的个人博客"/>
            WuRuoHui 的个人博客
        </a>

        <nav class="header__nav mobile__none">
            <a href="https://wuruohui.github.io/tags.html" rel="section">
                Tags
            </a>
            <a href="https://wuruohui.github.io/archives.html">
                Archives
            </a>
            <a rel="archive" href="https://wuruohui.github.io/links.html">
                Links
            </a>
        </nav>

        <div class="header__bar fn__none" onclick="$(this).next().slideToggle()">
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">
                <path fill="#444" d="M0 3h20v2h-20v-2zM0 9h20v2h-20v-2zM0 15h20v2h-20v-2z"></path>
            </svg>
        </div>
        <main class="header__menu fn__none">
            <ul>
                <li>
                    <a href="https://wuruohui.github.io/tags.html" rel="section">
                        Tags
                    </a>
                </li>
                <li>
                    <a href="https://wuruohui.github.io/archives.html">
                        Archives
                    </a>
                </li>
                <li>
                    <a rel="archive" href="https://wuruohui.github.io/links.html">
                        Links
                    </a>
                </li>
                <li>
                    <a rel="alternate" href="https://wuruohui.github.io/rss.xml" rel="section">
                        RSS
                    </a>
                </li>
            </ul>
        </main>
    </div>
</header>
<main id="pjax" class="fn__flex-1">
    
    <div class="post wrapper wrapper--miner">
        <h2 class="item__title">
            <a rel="bookmark" href="https://wuruohui.github.io/articles/2020/11/26/1606349708094.html">
                Spring Boot与Web
            </a>
        </h2>
        <div class="ft__fade item__meta">
                Published on
            <time>
                Nov 26, 2020
            </time>
            with <span data-uvstaturl="https://wuruohui.github.io/articles/2020/11/26/1606349708094.html">0</span> views
                and <a href="#b3logsolocomments"><span data-uvstatcmt="1606349708212">0</span> comments</a>
        </div>
        <div class="item__tags">
                <a rel="tag" class="tag tag--0" href="https://wuruohui.github.io/tags/SpringBoot">
                    <b># SpringBoot</b>
                </a>
                <a rel="tag" class="tag tag--1" href="https://wuruohui.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">
                    <b># 学习笔记</b>
                </a>
        </div>
        <div class="vditor-reset">
            <h2 id="toc_h2_0">1、简介</h2>
<p>使用SpringBoot；</p>
<p><strong>1）、创建SpringBoot应用，选中我们需要的模块；</strong></p>
<p><strong>2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</strong></p>
<p><strong>3）、自己编写业务代码；</strong></p>
<p><strong>自动配置原理？</strong></p>
<p>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx</p>
<pre><code>xxxxAutoConfiguration：帮我们给容器中自动配置组件；
xxxxProperties:配置类来封装配置文件的内容；
</code></pre>
<h2 id="toc_h2_1">2、SpringBoot对静态资源的映射规则；</h2>
<pre><code class="language-java">@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)
public class ResourceProperties implements ResourceLoaderAware {
  //可以设置和静态资源有关的参数，缓存时间等
</code></pre>
<pre><code class="language-java">WebMvcAuotConfiguration：
		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			if (!this.resourceProperties.isAddMappings()) {
				logger.debug("Default resource handling disabled");
				return;
			}
			Integer cachePeriod = this.resourceProperties.getCachePeriod();
			if (!registry.hasMappingForPattern("/webjars/**")) {
				customizeResourceHandlerRegistration(
						registry.addResourceHandler("/webjars/**")
								.addResourceLocations(
										"classpath:/META-INF/resources/webjars/")
						.setCachePeriod(cachePeriod));
			}
			String staticPathPattern = this.mvcProperties.getStaticPathPattern();
          	//静态资源文件夹映射
			if (!registry.hasMappingForPattern(staticPathPattern)) {
				customizeResourceHandlerRegistration(
						registry.addResourceHandler(staticPathPattern)
								.addResourceLocations(
										this.resourceProperties.getStaticLocations())
						.setCachePeriod(cachePeriod));
			}
		}

        //配置欢迎页映射
		@Bean
		public WelcomePageHandlerMapping welcomePageHandlerMapping(
				ResourceProperties resourceProperties) {
			return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),
					this.mvcProperties.getStaticPathPattern());
		}

       //配置喜欢的图标
		@Configuration
		@ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true)
		public static class FaviconConfiguration {

			private final ResourceProperties resourceProperties;

			public FaviconConfiguration(ResourceProperties resourceProperties) {
				this.resourceProperties = resourceProperties;
			}

			@Bean
			public SimpleUrlHandlerMapping faviconHandlerMapping() {
				SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
				mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);
              	//所有  **/favicon.ico 
				mapping.setUrlMap(Collections.singletonMap("**/favicon.ico",
						faviconRequestHandler()));
				return mapping;
			}

			@Bean
			public ResourceHttpRequestHandler faviconRequestHandler() {
				ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler();
				requestHandler
						.setLocations(this.resourceProperties.getFaviconLocations());
				return requestHandler;
			}

		}
</code></pre>
<ol>
<li>、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；</li>
</ol>
<p>​	webjars：以jar包的方式引入静态资源；</p>
<p><a href="http://www.webjars.org/" target="_blank">http://www.webjars.org/</a></p>
<p><img src="images/搜狗截图20180203181751.png" alt=""></p>
<p>localhost:8080/webjars/jquery/3.3.1/jquery.js</p>
<pre><code class="language-xml">&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可
		&lt;dependency&gt;
			&lt;groupId&gt;org.webjars&lt;/groupId&gt;
			&lt;artifactId&gt;jquery&lt;/artifactId&gt;
			&lt;version&gt;3.3.1&lt;/version&gt;
		&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>、"/**" 访问当前项目的任何资源，都去（静态资源的文件夹）找映射</li>
</ol>
<pre><code>"classpath:/META-INF/resources/", 
"classpath:/resources/",
"classpath:/static/", 
"classpath:/public/" 
"/"：当前项目的根路径
</code></pre>
<p>localhost:8080/abc ===  去静态资源文件夹里面找abc</p>
<ol start="3">
<li>、欢迎页； 静态资源文件夹下的所有index.html页面；被"/**"映射；</li>
</ol>
<p>​	localhost:8080/   找index页面</p>
<ol start="4">
<li>、所有的 **/favicon.ico  都是在静态资源文件下找；</li>
</ol>
<h2 id="toc_h2_2">3、模板引擎</h2>
<p>JSP、Velocity、Freemarker、Thymeleaf</p>
<p><img src="images/template-engine.png" alt=""></p>
<p>SpringBoot推荐的Thymeleaf；</p>
<p>语法更简单，功能更强大；</p>
<h3 id="toc_h3_3">1、引入thymeleaf；</h3>
<pre><code class="language-xml">&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
          	2.1.6
		&lt;/dependency&gt;
切换thymeleaf版本
&lt;properties&gt;
		&lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;
		&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;
		&lt;!-- thymeleaf2   layout1--&gt;
		&lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;
  &lt;/properties&gt;
</code></pre>
<h3 id="toc_h3_4">2、Thymeleaf使用</h3>
<pre><code class="language-java">@ConfigurationProperties(prefix = "spring.thymeleaf")
public class ThymeleafProperties {

	private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8");

	private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html");

	public static final String DEFAULT_PREFIX = "classpath:/templates/";

	public static final String DEFAULT_SUFFIX = ".html";
  	//
</code></pre>
<p>只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；</p>
<p>使用：</p>
<ol>
<li>导入thymeleaf的名称空间</li>
</ol>
<pre><code class="language-xml">&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
</code></pre>
<ol start="2">
<li>使用thymeleaf语法；</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;成功！&lt;/h1&gt;
    &lt;!--th:text 将div里面的文本内容设置为 --&gt;
    &lt;div th:text="${hello}"&gt;这是显示欢迎信息&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="toc_h3_5">3、语法规则</h3>
<ol>
<li>、th:text；改变当前元素里面的文本内容；</li>
</ol>
<p>​	th：任意html属性；来替换原生属性的值</p>
<p><img src="images/2018-02-04_123955.png" alt=""></p>
<ol start="2">
<li>、表达式？</li>
</ol>
<pre><code class="language-properties">Simple expressions:（表达式语法）
    Variable Expressions: ${...}：获取变量值；OGNL；
    		1）、获取对象的属性、调用方法
    		2）、使用内置的基本对象：
    			#ctx : the context object.
    			#vars: the context variables.
                #locale : the context locale.
                #request : (only in Web Contexts) the HttpServletRequest object.
                #response : (only in Web Contexts) the HttpServletResponse object.
                #session : (only in Web Contexts) the HttpSession object.
                #servletContext : (only in Web Contexts) the ServletContext object.
              
                ${session.foo}
            3）、内置的一些工具对象：
                #execInfo : information about the template being processed.
                #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.
                #uris : methods for escaping parts of URLs/URIs
                #conversions : methods for executing the configured conversion service (if any).
                #dates : methods for java.util.Date objects: formatting, component extraction, etc.
                #calendars : analogous to #dates , but for java.util.Calendar objects.
                #numbers : methods for formatting numeric objects.
                #strings : methods for String objects: contains, startsWith, prepending/appending, etc.
                #objects : methods for objects in general.
                #bools : methods for boolean evaluation.
                #arrays : methods for arrays.
                #lists : methods for lists.
                #sets : methods for sets.
                #maps : methods for maps.
                #aggregates : methods for creating aggregates on arrays or collections.
                #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).

    Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；
    	补充：配合 th:object="${session.user}；*{firstName}表示取到前面user对象的firstName属性
            &lt;div th:object="${session.user}"&gt;
                &lt;p&gt;Name: &lt;span th:text="*{firstName}"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;
                &lt;p&gt;Surname: &lt;span th:text="*{lastName}"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;
                &lt;p&gt;Nationality: &lt;span th:text="*{nationality}"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;
            &lt;/div&gt;
  
    Message Expressions: #{...}：获取国际化内容
    Link URL Expressions: @{...}：定义URL；
    		@{/order/process(execId=${execId},execType='FAST')}
    Fragment Expressions: ~{...}：片段引用表达式
    		&lt;div th:insert="~{commons :: main}"&gt;...&lt;/div&gt;
    	
Literals（字面量）
      Text literals: 'one text' , 'Another one!' ,…
      Number literals: 0 , 34 , 3.0 , 12.3 ,…
      Boolean literals: true , false
      Null literal: null
      Literal tokens: one , sometext , main ,…
Text operations:（文本操作）
    String concatenation: +
    Literal substitutions: |The name is ${name}|
Arithmetic operations:（数学运算）
    Binary operators: + , - , * , / , %
    Minus sign (unary operator): -
Boolean operations:（布尔运算）
    Binary operators: and , or
    Boolean negation (unary operator): ! , not
Comparisons and equality:（比较运算）
    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )
    Equality operators: == , != ( eq , ne )
Conditional operators:条件运算（三元运算符）
    If-then: (if) ? (then)
    If-then-else: (if) ? (then) : (else)
    Default: (value) ?: (defaultvalue)
Special tokens:
    No-Operation: _
</code></pre>
<h2 id="toc_h2_6">4、SpringMVC自动配置</h2>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications" target="_blank">https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications</a></p>
<h3 id="toc_h3_7">1. Spring MVC auto-configuration</h3>
<p>Spring Boot 自动配置好了SpringMVC</p>
<p>以下是SpringBoot对SpringMVC的默认配置:<strong>==（WebMvcAutoConfiguration）==</strong></p>
<ul>
<li>
<p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
<ul>
<li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li>
<li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li>
<li>如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；</li>
</ul>
</li>
<li>
<p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p>
</li>
<li>
<p>Static <code>index.html</code> support. 静态首页访问</p>
</li>
<li>
<p>Custom <code>Favicon</code> support (see below).  favicon.ico</p>
</li>
<li>
<p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p>
<ul>
<li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li>
<li><code>Formatter</code>  格式化器；  2017.12.17===Date；</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Bean
		@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则
		public Formatter&lt;Date&gt; dateFormatter() {
			return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件
		}
</code></pre>
<p>​	==自己添加的格式化器转换器，我们只需要放在容器中即可==</p>
<ul>
<li>
<p>Support for <code>HttpMessageConverters</code> (see below).</p>
<ul>
<li>
<p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User---Json；</p>
</li>
<li>
<p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p>
<p>==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==</p>
</li>
</ul>
</li>
<li>
<p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p>
</li>
<li>
<p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p>
<p>==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==</p>
<pre><code>初始化WebDataBinder；
请求数据=====JavaBean；
</code></pre>
</li>
</ul>
<p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p>
<p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc" target="_blank">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p>
<h3 id="toc_h3_8">2.扩展 SpringMVC</h3>
<pre><code>&lt;mvc:view-controller path="/hello" view-name="success"/&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path="/hello"/&gt;
        &lt;bean&gt;&lt;/bean&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<p>** 编写一个配置类（@Configuration），是 WebMvcConfigurerAdapter 类型；不能标注@EnableWebMvc**;</p>
<p>既保留了所有的自动配置，也能用我们扩展的配置；</p>
<pre><code>@Configuration
public class MyMVCConfig implements WebMvcConfigurer {
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/wu").setViewName("success");
    }
}
</code></pre>
<p>原理：</p>
<ol>
<li>、WebMvcAutoConfiguration 是 SpringMVC 的自动配置类</li>
<li>、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</li>
</ol>
<pre><code>@Configuration
public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {
    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();
    //从容器中获取所有的WebMvcConfigurer
    @Autowired(required = false)
    public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {
        if (!CollectionUtils.isEmpty(configurers)) {
            this.configurers.addWebMvcConfigurers(configurers);
            //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  
            @Override
             // public void addViewControllers(ViewControllerRegistry registry) {
              //    for (WebMvcConfigurer delegate : this.delegates) {
               //       delegate.addViewControllers(registry);
               //   }
              }
          }
	}
</code></pre>
<ol>
<li>、容器中所有的 WebMvcConfigurer 都会一起起作用；</li>
<li>、我们的配置类也会被调用；</li>
</ol>
<p>效果：SpringMVC 的自动配置和我们的扩展配置都会起作用；</p>
<h3 id="toc_h3_9">3、全面接管 SpringMVC；</h3>
<p>SpringBoot 对 SpringMVC 的自动配置不需要了，所有都是我们自己配置；所有的 SpringMVC 的自动配置都失效了</p>
<p><strong>我们需要在配置类中添加@EnableWebMvc 即可；</strong></p>
<pre><code>@EnableWebMvc
@Configuration
public class MyMVCConfig implements WebMvcConfigurer {
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/wu").setViewName("success");
    }
}
</code></pre>
<p>原理：</p>
<p>为什么@EnableWebMvc 自动配置就失效了；</p>
<ol>
<li>@EnableWebMvc 的核心</li>
</ol>
<pre><code class="language-java">@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
  
}
</code></pre>
<p>2）</p>
<pre><code class="language-java">@Configuration
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
</code></pre>
<p>3）</p>
<pre><code class="language-java">@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,
		WebMvcConfigurerAdapter.class })
//容器中没有这个组件的时候，这个自动配置类才生效
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,
		ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {
</code></pre>
<ol>
<li>、@EnableWebMvc 将 WebMvcConfigurationSupport 组件导入进来；</li>
<li>、导入的 WebMvcConfigurationSupport 只是 SpringMVC 最基本的功能；</li>
</ol>
<p>从 3 中看出，只有容器中没有 WebMvcConfigurationSupport 这个组件时自动配置才会生效，而 1 中以及 import 进了这个组件，所以 SpringBoot 的自动配置失效了</p>
<h3 id="toc_h3_10">如何修改 SpringBoot 的默认配置</h3>
<p>模式：</p>
<ol>
<li>、SpringBoot 在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</li>
<li>、在 SpringBoot 中会有非常多的 xxxConfigurer 帮助我们进行扩展配置</li>
<li>、在 SpringBoot 中会有很多的 xxxCustomizer 帮助我们进行定制配置</li>
</ol>
<h2 id="toc_h2_11">国际化</h2>
<p><strong>1.编写国际化配置文件</strong></p>
<p>2.使用 ResourcesBundleMessageSource 管理国际化资源文件</p>
<p>3.在页面使用 fmt:message 取出国际化内容</p>
<p>步骤：</p>
<p>1.编写国际化配置文件，抽取页面需要显示的国际化消息</p>
<p><img src="https://b3logfile.com/file/2020/12/image-974a3293.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image.png"></p>
<p>2.SpringBoot 自动配置好了管理国际化资源文件的组件</p>
<p>在主配置文件中配置国际化，/i18n/xxx.properties 写成 i18n.xxx</p>
<pre><code class="language-properties">#国际化资源文件
spring.messages.basename=i18n.login
</code></pre>
<pre><code class="language-java">@Bean
public MessageSource messageSource(MessageSourceProperties properties) {
    /**
	 * Comma-separated list of basenames (essentially a fully-qualified classpath
	 * location), each following the ResourceBundle convention with relaxed support for
	 * slash based locations. If it doesn't contain a package qualifier (such as
	 * "org.mypackage"), it will be resolved from the classpath root.
	 */
	private String basename = "messages";  
    //我们的配置文件可以直接放在类路径下叫messages.properties；
  
    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
    if (StringUtils.hasText(properties.getBasename())) {
        //设置国际化资源文件的基础名（去掉语言国家代码的）
        messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename())));
    }

    if (properties.getEncoding() != null) {
        messageSource.setDefaultEncoding(properties.getEncoding().name());
    }

    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
    Duration cacheDuration = properties.getCacheDuration();
    if (cacheDuration != null) {
        messageSource.setCacheMillis(cacheDuration.toMillis());
    }

    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());
    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());
    return messageSource;
}
</code></pre>
<p>3.如何取国际化信息</p>
<p>和 <code>${}</code> 类似，取国际化信息使用 <code>#{}</code></p>
<pre><code>&lt;label class="sr-only" th:text="#{login.password}"&gt;Password&lt;/label&gt;
&lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#{login.password}" required=""&gt;
&lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#{login.btn}"&gt;Sign in&lt;/button&gt;
</code></pre>
<p>效果：根据浏览器语言设置信息切换国际化</p>
<p>原理：国际化 Locale（区域信息对象）；LocaleResolver（获取区域信息对象）</p>
<p>默认是根据请求头带来的区域信息获取 Locale 进行国际化</p>
<pre><code>@Bean
@ConditionalOnMissingBean
@ConditionalOnProperty(
    prefix = "spring.mvc",
    name = {"locale"}
)
public LocaleResolver localeResolver() {
    if (this.mvcProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties.LocaleResolver.FIXED) {
        return new FixedLocaleResolver(this.mvcProperties.getLocale());
    } else {
        AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
        localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
        return localeResolver;
    }
}
</code></pre>
<p>4.点击链接切换国际化</p>
<pre><code class="language-html">&lt;!-- /指的是访问页面的路径，如果访问路径是/index.html的话，@{/index.html(l='zh_CN')}，(l='zh_CN')是thymeleaf模板的功能，表示的是url后缀带着?l=zh_CN --&gt;
&lt;a class="btn btn-sm" th:href="@{/(l='zh_CN')}"&gt;中文&lt;/a&gt;
&lt;a class="btn btn-sm" th:href="@{/(l='en_US')}"&gt;English&lt;/a&gt;
</code></pre>
<pre><code class="language-java">/*
*   可以在链接上携带区域信息
*/
//自己编写的组件类
public class MyLocaleResolver implements LocaleResolver {
    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        String l = request.getParameter("l");
        Locale locale = Locale.getDefault();
        if (!StringUtils.isEmpty(l)) {
            String[] split = l.split("_");
            locale = new Locale(split[0],split[1]);
        }
        return locale;
    }

    @Override
    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) {

    }
}

//在配置类中注入组件
@Configuration
public class MyMVCConfig implements WebMvcConfigurer {
    @Bean
    public LocaleResolver localeResolver() {
        return new MyLocaleResolver();
    }
}
</code></pre>
<p>5.登录</p>
<p>开发期间模板引擎页面修改以后，要实时生效</p>
<ol>
<li>禁用模板引擎的缓存</li>
</ol>
<pre><code># 禁用缓存
spring.thymeleaf.cache=false
</code></pre>
<p>2.页面修改完成以后 ctrl+f9：重新编译；</p>
<p>登陆错误消息的显示</p>
<pre><code class="language-html">&lt;p style="color: red" th:text="${msg}" th:if="${not #strings.isEmpty(msg)}"&gt;&lt;/p&gt;
</code></pre>
<h2 id="toc_h2_12">拦截器进行登陆检查</h2>
<p>拦截器</p>
<pre><code>public class LoginHandlerInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        Object user = request.getSession().getAttribute("loginUser");
        if (user == null) {
            request.setAttribute("msg","没有权限");
            request.getRequestDispatcher("/").forward(request,response);
            return false;
        } else {
            return true;
        }
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}
</code></pre>
<p>注册拦截器</p>
<pre><code>//所有的WebMvcConfigurerAdapter组件都会一起起作用
    @Bean
    public WebMvcConfigurer webMvcConfigurer() {
        WebMvcConfigurer webMvcConfigurer = new WebMvcConfigurer() {
            //注册拦截器
            @Override
            public void addInterceptors(InterceptorRegistry registry) {
                //super.addInterceptors(registry);
                //静态资源；  *.css , *.js
                //SpringBoot已经做好了静态资源映射
                registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**")
                .excludePathPatterns("/","/user/login");
            }

            @Override
            public void addViewControllers(ViewControllerRegistry registry) {
                registry.addViewController("/").setViewName("index");
                registry.addViewController("/main.html").setViewName("dashboard");
            }
        };
        return webMvcConfigurer;
    }
</code></pre>
<h2 id="toc_h2_13">简单例子</h2>
<ol>
<li>RestfulCRUD：CRUD 满足 Rest 风格；</li>
</ol>
<p>URI： /资源名称/资源标识 HTTP 请求方式区分对资源 CRUD 操作</p>
<table>
<thead>
<tr><th> </th><th>普通 CRUD（uri 来区分操作）</th><th>RestfulCRUD</th></tr>
</thead>
<tbody>
<tr><td>查询</td><td>getEmp</td><td>emp---GET</td></tr>
<tr><td>添加</td><td>addEmp?xxx</td><td>emp---POST</td></tr>
<tr><td>修改</td><td>updateEmp?id=xxx&amp;xxx=xx</td><td>emp/{id}---PUT</td></tr>
<tr><td>删除</td><td>deleteEmp?id=1</td><td>emp/{id}---DELETE</td></tr>
</tbody>
</table>
<ol start="2">
<li>请求架构</li>
</ol>
<table>
<thead>
<tr><th>实验功能</th><th>请求 URI</th><th>请求方式</th></tr>
</thead>
<tbody>
<tr><td>查询所有员工</td><td>emps</td><td>GET</td></tr>
<tr><td>查询某个员工(来到修改页面)</td><td>emp/1</td><td>GET</td></tr>
<tr><td>来到添加页面</td><td>emp</td><td>GET</td></tr>
<tr><td>添加员工</td><td>emp</td><td>POST</td></tr>
<tr><td>来到修改页面（查出员工进行信息回显）</td><td>emp/1</td><td>GET</td></tr>
<tr><td>修改员工</td><td>emp</td><td>PUT</td></tr>
<tr><td>删除员工</td><td>emp/1</td><td>DELETE</td></tr>
</tbody>
</table>
<h4 id="toc_h4_14">thymeleaf 公共页面元素抽取</h4>
<pre><code class="language-html">1. 抽取公共片段
&lt;div th:fragment="copy"&gt;
© 2011 The Good Thymes Virtual Grocery
&lt;/div&gt;

2. 引入公共片段
&lt;div th:insert="~{footer :: copy}"&gt;&lt;/div&gt;
~{templatename::selector}：模板名::选择器
~{templatename::fragmentname}:模板名::片段名

3. 默认效果：

insert的公共片段在div标签中
如果使用th:insert等属性进行引入，可以不用写~{}：
行内写法可以加上：[[~{}]];[(~{})]；

三种引入公共片段的th属性：

**th:insert**：将公共片段整个插入到声明引入的元素中

**th:replace**：将声明引入的元素替换为公共片段

**th:include**：将被引入的片段的内容包含进这个标签中
</code></pre>
<p>引入片段的时候传入参数：</p>
<pre><code class="language-html">&lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"&gt;
    &lt;div class="sidebar-sticky"&gt;
        &lt;ul class="nav flex-column"&gt;
            &lt;li class="nav-item"&gt;
                &lt;a class="nav-link active"
                   th:class="${activeUri=='main.html'?'nav-link active':'nav-link'}"
                   href="#" th:href="@{/main.html}"&gt;
                    &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"&gt;
                        &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"&gt;&lt;/path&gt;
                        &lt;polyline points="9 22 9 12 15 12 15 22"&gt;&lt;/polyline&gt;
                    &lt;/svg&gt;
                    Dashboard &lt;span class="sr-only"&gt;(current)&lt;/span&gt;
                &lt;/a&gt;
            &lt;/li&gt;

&lt;!--引入侧边栏;传入参数--&gt;
&lt;div th:replace="commons/bar::#sidebar(activeUri='emps')"&gt;&lt;/div&gt;
</code></pre>
<h4 id="toc_h4_15">日期格式化</h4>
<p>提交的数据格式不对：生日：日期；</p>
<p>2017-12-12；2017/12/12；2017.12.12；</p>
<p>日期的格式化；SpringMVC 将页面提交的值需要转换为指定的类型;</p>
<p>2017-12-12---Date； 类型转换，格式化;</p>
<p>默认日期是按照/的方式；</p>
<pre><code class="language-properties">#在配置文件中修改指定格式
spring.mvc.format.date-time=yyyy-MM-dd HH:mm
</code></pre>
<h4 id="toc_h4_16">_method</h4>
<p>区分表单是 post 还是 put 提交</p>
<pre><code>&lt;!--发送put请求修改员工数据--&gt;
&lt;!--
1. SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）
2. 页面创建一个post表单
3. 创建一个input项，name="_method";值就是我们指定的请求方式
--&gt;
&lt;input type="hidden" name="_method" value="put" th:if="${emp!=null}"/&gt;
</code></pre>
<pre><code class="language-properties">#由于SpringBoot版本问题，不生效的话要开启hiddenmethod.filter
spring.mvc.hiddenmethod.filter.enabled=true
</code></pre>
<h2 id="toc_h2_17">SpringBoot 的错误处理</h2>
<h4 id="toc_h4_18">SpringBoot 默认的错误处理机制</h4>
<p>默认效果：</p>
<p>（1）浏览器，返回一个默认的错误页面</p>
<p>（2）如果是其他客户端，会返回一个 JSON 数据</p>
<p><img src="https://b3logfile.com/file/2020/12/image-4ea6cf70.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image.png"></p>
<p>原理：可以参照 ErrorMVCAutoConfiguration，错误处理的自动配置</p>
<p>给容器中添加了以下组件</p>
<p>1.DefaultErrorAttributes</p>
<pre><code class="language-java">帮我们在页面共享信息；
@Override
public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes,
		boolean includeStackTrace) {
	Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;();
	errorAttributes.put("timestamp", new Date());
	addStatus(errorAttributes, requestAttributes);
	addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);
	addPath(errorAttributes, requestAttributes);
	return errorAttributes;
}
</code></pre>
<p>2.BasicErrorController：处理默认/error 请求</p>
<pre><code class="language-java">@Controller
@RequestMapping("${server.error.path:${error.path:/error}}")
public class BasicErrorController extends AbstractErrorController {
  
    @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理
	public ModelAndView errorHtml(HttpServletRequest request,
			HttpServletResponse response) {
		HttpStatus status = getStatus(request);
		Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(
				request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));
		response.setStatus(status.value());
      
        //去哪个页面作为错误页面；包含页面地址和页面内容
		ModelAndView modelAndView = resolveErrorView(request, response, status, model);
		return (modelAndView == null ? new ModelAndView("error", model) : modelAndView);
	}

	@RequestMapping
	@ResponseBody    //产生json数据，其他客户端来到这个方法处理；
	public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) {
		Map&lt;String, Object&gt; body = getErrorAttributes(request,
				isIncludeStackTrace(request, MediaType.ALL));
		HttpStatus status = getStatus(request);
		return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);
	}
</code></pre>
<p>3.ErrorPageCustomizer</p>
<pre><code class="language-java">@Value("${error.path:/error}")
private String path = "/error";  系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）
</code></pre>
<p>4.DefaultErrorViewResolver</p>
<pre><code class="language-java">@Override
public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,
		Map&lt;String, Object&gt; model) {
	ModelAndView modelAndView = resolve(String.valueOf(status), model);
	if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) {
		modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);
	}
	return modelAndView;
}

private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) {
    //默认SpringBoot可以去找到一个页面？  error/404
	String errorViewName = "error/" + viewName;
  
    //模板引擎可以解析这个页面地址就用模板引擎解析
	TemplateAvailabilityProvider provider = this.templateAvailabilityProviders
			.getProvider(errorViewName, this.applicationContext);
	if (provider != null) {
        //模板引擎可用的情况下返回到errorViewName指定的视图地址
		return new ModelAndView(errorViewName, model);
	}
    //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html
	return resolveResource(errorViewName, model);
}
</code></pre>
<p>步骤：一旦系统出现 4xx 或者 5xx 之类的错误，ErrorPageCustomizer 就会生效（定制错误的响应规则），就会来到/error 请求，就会被 BasicErrorController 处理</p>
<p>（1）响应页面：去哪个页面是由 DefaultErrorViewResolver 解析得到的</p>
<pre><code class="language-java">protected ModelAndView resolveErrorView(HttpServletRequest request,
      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) {
    //所有的ErrorViewResolver得到ModelAndView
   for (ErrorViewResolver resolver : this.errorViewResolvers) {
      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);
      if (modelAndView != null) {
         return modelAndView;
      }
   }
   return null;
}
</code></pre>
<h4 id="toc_h4_19">如何定制错误响应</h4>
<p>（1）如何定制错误页面</p>
<p>a.有模板引擎的情况下，error/状态码，将错误页面命名为错误状态码.html 放在模板引擎文件夹里面的 error 文件夹下，发生此状态码的错误就会来到对应的错误页面</p>
<p>可以使用 4xx 和 5xx 作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）</p>
<p>页面能获取的信息；</p>
<p>timestamp：时间戳</p>
<p>status：状态码</p>
<p>error：错误提示</p>
<p>exception：异常对象</p>
<p>message：异常消息</p>
<p>errors：JSR303 数据校验的错误都在这里</p>
<p>b.没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；</p>
<p>c.以上都没有错误页面，就是默认来到 SpringBoot 默认的错误提示页面；</p>
<p>（2）如何定制错误的 JSON 数据</p>
<p>1.自定义异常处理&amp;返回定制 JSON 数据；</p>
<pre><code class="language-java">@ControllerAdvice
public class MyExceptionHandler {
    //浏览器、客户端返回的都是json
    @ResponseBody
    @ExceptionHandler(UserNotExistException.class)
    public Map&lt;String,Object&gt; handleException(Exception e){
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put("code","user.notexist");
        map.put("message",e.getMessage());
        return map;
    }
}
//没有自适应效果...
</code></pre>
<p>2.转发到/error 进行自适应响应效果处理</p>
<pre><code class="language-java">@ExceptionHandler(UserNotExistException.class)
    public String handleException(Exception e, HttpServletRequest request){
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        //传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程
        /**
         * Integer statusCode = (Integer) request
         .getAttribute("javax.servlet.error.status_code");
         */
        request.setAttribute("javax.servlet.error.status_code",500);
        map.put("code","user.notexist");
        map.put("message",e.getMessage());
        //转发到/error
        return "forward:/error";
    }
</code></pre>
<p>3.将我们的定制数据携带出去；</p>
<p>出现错误以后，会来到/error 请求，会被 BasicErrorController 处理，响应出去可以获取的数据是由 getErrorAttributes 得到的（是 AbstractErrorController（ErrorController）规定的方法）；</p>
<p>（1） 完全来编写一个 ErrorController 的实现类【或者是编写 AbstractErrorController 的子类】，放在容器中；</p>
<pre><code>（2） 页面上能用的数据，或者是 JSON 返回能用的数据都是通过 errorAttributes.getErrorAttributes 得到；
</code></pre>
<pre><code>容器中 DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；
</code></pre>
<p>自定义 ErrorAttributes</p>
<pre><code class="language-java">//给容器中加入我们自己定义的ErrorAttributes
@Component
public class MyErrorAttributes extends DefaultErrorAttributes {

    //返回的map就是页面和json能获取的所有字段
    @Override
    public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) {
        Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace);
        map.put("company","atguigu");
        return map;
    }
}
</code></pre>
<p>最终的效果：响应是自适应的，可以通过定制 ErrorAttributes 改变需要返回的内容，</p>
<h2 id="toc_h2_20">配置嵌入式servlet容器</h2>
<p>SpringBoot 默认使用的 Tomcat 作为嵌入式的 Servlet 容器</p>
<p><img src="https://b3logfile.com/file/2020/12/image-b6edf77d.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image.png"></p>
<h4 id="toc_h4_21">如何定制和修改 servlet 容器的相关配置</h4>
<ol>
<li>方式一：修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；</li>
</ol>
<pre><code class="language-properties">server.port=8081
server.context-path=/crud

server.tomcat.uri-encoding=UTF-8

//通用的Servlet容器设置
server.xxx
//Tomcat的设置
server.tomcat.xxx
</code></pre>
<ol start="2">
<li>方式二：编写一个 <strong>EmbeddedServletContainerCustomizer</strong>：嵌入式的 Servlet 容器的定制器；来修改 Servlet 容器的配置</li>
</ol>
<pre><code class="language-java">//SpringBoot1.xxx
@Bean  //一定要将这个定制器加入到容器中
public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){
    return new EmbeddedServletContainerCustomizer() {
        //定制嵌入式的Servlet容器相关的规则
        @Override
        public void customize(ConfigurableEmbeddedServletContainer container) {
            container.setPort(8083);
        }
    };
}
</code></pre>
<pre><code class="language-java">//SpringBoot2.xxx
@Bean
public WebServerFactoryCustomizer webServerFactoryCustomizer() {
    return new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;() {
        @Override
        public void customize(ConfigurableWebServerFactory factory) {
            factory.setPort(8081);
        }
    };
}
</code></pre>
<h4 id="toc_h4_22">注册三大组件，Servlet、Filter、Listener</h4>
<p>由于 SpringBoot 默认是以 jar 包的方式启动嵌入式的 Servlet 容器来启动 SpringBoot 的 Web 应用，没有 web.xml 文件。</p>
<p>注册三大组件用以下方式（在配置类中编写）</p>
<p>ServletRegistrationBean</p>
<pre><code class="language-java">@Bean
public ServletRegistrationBean myServlet() {
    ServletRegistrationBean&lt;Servlet&gt; servletRegistrationBean = new ServletRegistrationBean&lt;&gt;(new MyServlet(),"/myServlet");   //参数1为自己编写的servlet。参数2是该servlet的映射路径
    return servletRegistrationBean;
}
</code></pre>
<p>FilterRegistrationBean</p>
<pre><code class="language-java">@Bean
public FilterRegistrationBean myFilter(){
    FilterRegistrationBean registrationBean = new FilterRegistrationBean();
    registrationBean.setFilter(new MyFilter());   //添加自己编写的拦截器
    registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet"));   //拦截路径的数组
    return registrationBean;
}
</code></pre>
<p>ServletListenerRegistrationBean</p>
<pre><code class="language-java">@Bean
public ServletListenerRegistrationBean myListener(){
    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener());
    return registrationBean;
}
</code></pre>
<p>SpringBoot 帮我们自动 SpringMVC 的时候，自动的注册 SpringMVC 的前端控制器；DIspatcherServlet；</p>
<p>DispatcherServletAutoConfiguration 中：</p>
<pre><code class="language-java">@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
public ServletRegistrationBean dispatcherServletRegistration(
      DispatcherServlet dispatcherServlet) {
   ServletRegistrationBean registration = new ServletRegistrationBean(
         dispatcherServlet, this.serverProperties.getServletMapping());
    //默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp
    //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径
  
   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
   registration.setLoadOnStartup(
         this.webMvcProperties.getServlet().getLoadOnStartup());
   if (this.multipartConfig != null) {
      registration.setMultipartConfig(this.multipartConfig);
   }
   return registration;
}
</code></pre>
<h4 id="toc_h4_23">SpringBoot 能不能支持其他 servlet 容器</h4>
<p><img src="https://b3logfile.com/file/2020/12/image-6c3a0376.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image.png"></p>
<p>默认支持：</p>
<p>Tomcat（默认使用）</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；
&lt;/dependency&gt;
</code></pre>
<p>Jetty（长连接）</p>
<pre><code class="language-xml">&lt;!-- 引入web模块 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
   &lt;exclusions&gt;
      &lt;exclusion&gt;
         &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;!--引入其他的Servlet容器--&gt;
&lt;dependency&gt;
   &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Undertow（不支持JSP）</p>
<pre><code>&lt;!-- 引入web模块 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
   &lt;exclusions&gt;
      &lt;exclusion&gt;
         &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;!--引入其他的Servlet容器--&gt;
&lt;dependency&gt;
   &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="toc_h5_24">嵌入式 Servlet 容器自动配置原理</h5>
<p>EmbeddedServletContainerAutoConfiguration：嵌入式的 Servlet 容器自动配置</p>
<pre><code class="language-java">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication
@Import(BeanPostProcessorsRegistrar.class)
//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件
//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：
//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作
public class EmbeddedServletContainerAutoConfiguration {
  
    @Configuration
	@ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖；
	@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器
	public static class EmbeddedTomcat {

		@Bean
		public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {
			return new TomcatEmbeddedServletContainerFactory();
		}

	}
  
    /**
	 * Nested configuration if Jetty is being used.
	 */
	@Configuration
	@ConditionalOnClass({ Servlet.class, Server.class, Loader.class,
			WebAppContext.class })
	@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
	public static class EmbeddedJetty {

		@Bean
		public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() {
			return new JettyEmbeddedServletContainerFactory();
		}

	}

	/**
	 * Nested configuration if Undertow is being used.
	 */
	@Configuration
	@ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })
	@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
	public static class EmbeddedUndertow {

		@Bean
		public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() {
			return new UndertowEmbeddedServletContainerFactory();
		}

	}
</code></pre>
<p>1.EmbeddedServletContainerFactory（嵌入式 Servlet 容器工厂）</p>
<p>有三个：xxxEmbeddedServletContainerFactory</p>
<pre><code class="language-java">public interface EmbeddedServletContainerFactory {
   //获取嵌入式的Servlet容器
   EmbeddedServletContainer getEmbeddedServletContainer(
         ServletContextInitializer... initializers);
}
</code></pre>
<p>2.EmbeddedServletContainer：（嵌入式的 Servlet 容器）</p>
<p>有三个：xxxEmbeddedServletContainer</p>
<p>3.以 <strong>TomcatEmbeddedServletContainerFactory</strong> 为例</p>
<pre><code class="language-java">@Override
public EmbeddedServletContainer getEmbeddedServletContainer(
      ServletContextInitializer... initializers) {
    //创建一个Tomcat
   Tomcat tomcat = new Tomcat();
  
    //配置Tomcat的基本环境
   File baseDir = (this.baseDirectory != null ? this.baseDirectory
         : createTempDir("tomcat"));
   tomcat.setBaseDir(baseDir.getAbsolutePath());
   Connector connector = new Connector(this.protocol);
   tomcat.getService().addConnector(connector);
   customizeConnector(connector);
   tomcat.setConnector(connector);
   tomcat.getHost().setAutoDeploy(false);
   configureEngine(tomcat.getEngine());
   for (Connector additionalConnector : this.additionalTomcatConnectors) {
      tomcat.getService().addConnector(additionalConnector);
   }
   prepareContext(tomcat.getHost(), initializers);
  
    //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器
   return getTomcatEmbeddedServletContainer(tomcat);
}
</code></pre>
<h4 id="toc_h4_25">我们对嵌入式容器的配置修改是怎么生效？</h4>
<pre><code>ServerProperties、EmbeddedServletContainerCustomizer  //配置文件，定制器
</code></pre>
<p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了 Servlet 容器的配置？</p>
<p>怎么修改的原理？</p>
<p>容器中导入了 <strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong>：后置处理器</p>
<pre><code class="language-java">//初始化之前
@Override
public Object postProcessBeforeInitialization(Object bean, String beanName)
      throws BeansException {
    //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件
   if (bean instanceof ConfigurableEmbeddedServletContainer) {
       //
      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);
   }
   return bean;
}

private void postProcessBeforeInitialization(
			ConfigurableEmbeddedServletContainer bean) {
    //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；
    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {
        customizer.customize(bean);
    }
}

private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() {
    if (this.customizers == null) {
        // Look up does not include the parent context
        this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(
            this.beanFactory
            //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer
            //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件
            .getBeansOfType(EmbeddedServletContainerCustomizer.class,
                            false, false)
            .values());
        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);
        this.customizers = Collections.unmodifiableList(this.customizers);
    }
    return this.customizers;
}

ServerProperties也是定制器
</code></pre>
<p>步骤：</p>
<ol>
<li>SpringBoot 根据导入的依赖情况，给容器中添加相应的 EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</li>
<li>容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</li>
</ol>
<p>只要是嵌入式的 Servlet 容器工厂，后置处理器就工作； -- 从容器中获取所有的 <strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</p>
<h4 id="toc_h4_26">嵌入式 Servlet 容器启动原理；</h4>
<p>什么时候创建嵌入式的 Servlet 容器工厂？什么时候获取嵌入式的 Servlet 容器并启动 Tomcat；</p>
<p>获取嵌入式的 Servlet 容器工厂：</p>
<p>1.SpringBoot 应用启动运行 run 方法</p>
<p>2.refreshContext(context);SpringBoot 刷新 IoC 容器【创建 IoC 容器对象，并初始化容器，创建容器中的每一个组件】；如果是 Web 应用创建 <strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p>
<p>3.refresh(context);<strong>刷新刚才创建好的 IoC 容器；</strong></p>
<pre><code class="language-java">public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      prepareRefresh();

      // Tell the subclass to refresh the internal bean factory.
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // Prepare the bean factory for use in this context.
      prepareBeanFactory(beanFactory);

      try {
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);

         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);

         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);

         // Initialize message source for this context.
         initMessageSource();

         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();

         // Initialize other special beans in specific context subclasses.
         onRefresh();

         // Check for listener beans and register them.
         registerListeners();

         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);

         // Last step: publish corresponding event.
         finishRefresh();
      }

      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn("Exception encountered during context initialization - " +
                  "cancelling refresh attempt: " + ex);
         }

         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();

         // Reset 'active' flag.
         cancelRefresh(ex);

         // Propagate exception to caller.
         throw ex;
      }

      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
</code></pre>
<p>4.onRefresh(); Web 的 IoC 容器重写了 onRefresh 方法</p>
<p>5.webioc 容器会创建嵌入式的 Servlet 容器；<strong>createEmbeddedServletContainer</strong>();</p>
<p>6.<strong>获取嵌入式的 Servlet 容器工厂：</strong></p>
<p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p>
<pre><code>从 IoC 容器中获取 EmbeddedServletContainerFactory 组件；
</code></pre>
<p><strong>TomcatEmbeddedServletContainerFactory</strong> 创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制 Servlet 容器的相关配置；</p>
<p>7.<strong>使用容器工厂获取嵌入式的 Servlet 容器</strong>：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer());</p>
<p>8.嵌入式的 Servlet 容器创建对象并启动 Servlet 容器；</p>
<p><strong>先启动嵌入式的 Servlet 容器，再将 IoC 容器中剩下没有创建出的对象获取出来；</strong></p>
<p><strong>==IOC 容器启动创建嵌入式的 Servlet 容器 ==</strong></p>
<h4 id="toc_h4_27">使用外置的 servlet 容器</h4>
<p>嵌入式 Servlet 容器：应用打成可执行的 jar</p>
<p>优点：简单、便携；</p>
<p>缺点：默认不支持 JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义 EmbeddedServletContainerCustomizer】，自己编写嵌入式 Servlet 容器的创建工厂【EmbeddedServletContainerFactory】）；</p>
<p>外置的 Servlet 容器：外面安装 Tomcat---应用 war 包的方式打包；</p>
<h3 id="toc_h3_28">步骤</h3>
<ol>
<li>必须创建一个 war 项目；（利用 idea 创建好目录结构）</li>
<li>将嵌入式的 Tomcat 指定为 provided；</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
   &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="3">
<li>必须编写一个 <strong>SpringBootServletInitializer</strong> 的子类，并调用 configure 方法</li>
</ol>
<pre><code class="language-java">public class ServletInitializer extends SpringBootServletInitializer {

   @Override
   protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
       //传入SpringBoot应用的主程序
      return application.sources(SpringBoot04WebJspApplication.class);
   }

}
</code></pre>
<ol start="4">
<li>启动服务器就可以使用；</li>
</ol>
<h4 id="toc_h4_29">原理</h4>
<p>jar 包：执行 SpringBoot 主类的 main 方法，启动 IoC 容器，创建嵌入式的 Servlet 容器；</p>
<p>war 包：启动服务器，<strong>服务器启动 SpringBoot 应用</strong>【SpringBootServletInitializer】，启动 IoC 容器；</p>
<p>servlet3.0（Spring 注解版）：</p>
<p>8.2.4 Shared libraries / runtimes pluggability：</p>
<p>规则：</p>
<ol>
<li>服务器启动（Web 应用启动）会创建当前 Web 应用里面每一个 jar 包里面 ServletContainerInitializer 实例：</li>
<li>ServletContainerInitializer 的实现放在 jar 包的 META-INF/services 文件夹下，有一个名为 javax.servlet.ServletContainerInitializer 的文件，内容就是 ServletContainerInitializer 的实现类的全类名</li>
<li>还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</li>
</ol>
<p>流程：</p>
<ol>
<li>启动 Tomcat</li>
<li>org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</li>
</ol>
<p>Spring 的 Web 模块里面有这个文件：<strong>org.springframework.web.SpringServletContainerInitializer</strong></p>
<ol start="3">
<li>SpringServletContainerInitializer 将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到 onStartup 方法的 Set&lt;Class&lt;?&gt;&gt;；为这些 WebApplicationInitializer 类型的类创建实例；</li>
<li>每一个 WebApplicationInitializer 都调用自己的 onStartup；<br>
<img src="https://b3logfile.com/file/2020/12/image-63c74dfd.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="image.png"></li>
<li>相当于我们的 SpringBootServletInitializer 的类会被创建对象，并执行 onStartup 方法</li>
<li>SpringBootServletInitializer 实例执行 onStartup 的时候会 createRootApplicationContext；创建容器</li>
</ol>
<pre><code class="language-java">protected WebApplicationContext createRootApplicationContext(
   ServletContext servletContext) {
   //1、创建SpringApplicationBuilder
   SpringApplicationBuilder builder = createSpringApplicationBuilder();
   StandardServletEnvironment environment = new StandardServletEnvironment();
   environment.initPropertySources(servletContext, null);
   builder.environment(environment);
   builder.main(getClass());
   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);
   if (parent != null) {
   this.logger.info("Root context already created (using as parent).");
   servletContext.setAttribute(
   WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);
   builder.initializers(new ParentContextApplicationContextInitializer(parent));
   }
   builder.initializers(
   new ServletContextApplicationContextInitializer(servletContext));
   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);
   
   //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来
   builder = configure(builder);
   
   //使用builder创建一个Spring应用
   SpringApplication application = builder.build();
   if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils
   .findAnnotation(getClass(), Configuration.class) != null) {
   application.getSources().add(getClass());
   }
   Assert.state(!application.getSources().isEmpty(),
   "No SpringApplication sources have been defined. Either override the "
   
   + "configure method or add an @Configuration annotation");
     // Ensure error pages are registered
     if (this.registerErrorPageFilter) {
     application.getSources().add(ErrorPageFilterConfiguration.class);
     }
     //启动Spring应用
     return run(application);
     }
</code></pre>
<ol start="7">
<li>Spring 的应用就启动并且创建 IoC 容器</li>
</ol>
<pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   configureHeadlessProperty();
   SpringApplicationRunListeners listeners = getRunListeners(args);
   listeners.starting();
   try {
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
      Banner printedBanner = printBanner(environment);
      context = createApplicationContext();
      analyzers = new FailureAnalyzers(context);
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
     
       //刷新IOC容器
      refreshContext(context);
      afterRefresh(context, applicationArguments);
      listeners.finished(context, null);
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
      return context;
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   }
}
</code></pre>
<p><strong>== 启动 Servlet 容器，再启动 SpringBoot 应用 ==</strong></p>
                <div>
                    <hr>

标题：Spring Boot与Web<br>
作者：<a href="https://wuruohui.github.io" target="_blank">WuRuoHui</a><br>
地址：<a href="https://wuruohui.github.io/articles/2020/11/26/1606349708094.html" target="_blank">https://wuruohui.github.io/articles/2020/11/26/1606349708094.html</a><br>

<!-- 签名档内可使用 HTML、JavaScript -->
<br>
                </div>
        </div>
    </div>
    <div class="post__toc">
<ul class="article__toc">
        <li class="toc__h2">
            <a href="#toc_h2_0">1、简介</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_1">2、SpringBoot对静态资源的映射规则；</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_2">3、模板引擎</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_3">1、引入thymeleaf；</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_4">2、Thymeleaf使用</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_5">3、语法规则</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_6">4、SpringMVC自动配置</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_7">1. Spring MVC auto-configuration</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_8">2.扩展 SpringMVC</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_9">3、全面接管 SpringMVC；</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_10">如何修改 SpringBoot 的默认配置</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_11">国际化</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_12">拦截器进行登陆检查</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_13">简单例子</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_14">thymeleaf 公共页面元素抽取</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_15">日期格式化</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_16">_method</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_17">SpringBoot 的错误处理</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_18">SpringBoot 默认的错误处理机制</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_19">如何定制错误响应</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_20">配置嵌入式servlet容器</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_21">如何定制和修改 servlet 容器的相关配置</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_22">注册三大组件，Servlet、Filter、Listener</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_23">SpringBoot 能不能支持其他 servlet 容器</a>
        </li>
        <li class="toc__h5">
            <a href="#toc_h5_24">嵌入式 Servlet 容器自动配置原理</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_25">我们对嵌入式容器的配置修改是怎么生效？</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_26">嵌入式 Servlet 容器启动原理；</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_27">使用外置的 servlet 容器</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_28">步骤</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_29">原理</a>
        </li>
</ul>    </div>
    <div class="body--gray post__gray">
        <div class="wrapper comment">
                <div id="gitalk-container" style="padding: 30px 0;"></div>
                <div id="b3logsolocomments"></div>
                <div id="vcomment" style="padding: 30px 0;" data-name="WuRuoHui" data-postId="1606349708212"></div>

            <div class="post__list fn__flex">
                <div class="fn__flex-1">
                    <div id="externalRelevantArticles"></div>
                </div>
                <div class="post__list-mid fn__flex-1">
                    <div id="randomArticles"></div>
                </div>
                <div class="fn__flex-1">
                    <div id="relevantArticles"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="post__fix">
        <div class="wrapper">
            <span class="post__share mobile__none">
                Share
                <span class="tag tag--4" data-type="weibo">WeiBo</span>
                <span class="tag tag--5" data-type="twitter">Twitter</span>
                <span class="tag tag--6" data-type="qqz">QZone</span>
                <span class="post__code tag tag--7"
                      data-type="wechat"
                      data-title="Spring Boot与Web"
                      data-blogtitle="WuRuoHui 的个人博客"
                      data-url="https://wuruohui.github.io/articles/2020/11/26/1606349708094.html"
                      data-avatar="https://img.hacpai.com/avatar/1583717982177_1583772537638.jpeg?imageView2/1/w/128/h/128/interlace/0/q/100">
                    WeChat
                    <span class="qrcode"></span>
                </span>
            </span>
            <span class="post__arrow">
                    <a href="https://wuruohui.github.io/articles/2020/11/23/1606090789595.html" rel="prev"
                       class="vditor-tooltipped__n vditor-tooltipped"
                       pjax-title="Spring Boot与日志"
                       aria-label="旧一篇: Spring Boot与日志">←</a>

                    <a href="https://wuruohui.github.io/articles/2020/12/06/1607214139317.html" rel="next"
                       class="vditor-tooltipped__n vditor-tooltipped"
                       pjax-title="Spring Boot与数据访问"
                       aria-label="新一篇: Spring Boot与数据访问">→</a>
                <a href="javascript:Util.goTop()" class="vditor-tooltipped__n vditor-tooltipped"
                   aria-label="移动到顶部">↑</a>
                <a href="javascript:Util.goBottom()" class="vditor-tooltipped__n vditor-tooltipped"
                   aria-label="移动到底部">↓</a>
            </span>
        </div>
    </div>
    
</main>
<footer class="footer">
    <div class="ft__center">
    </div>
    <nav class="footer__nav mobile__none">
        <a class="ft__link" rel="alternate" href="https://wuruohui.github.io/rss.xml" rel="section">RSS</a>
    </nav>
    <div class="footer__border mobile__none"></div>
    <div class="wrapper fn__flex">
        <div class="fn__flex-1 mobile__none">
            <div class="ft__fade">WuRuoHui - 记录精彩的程序人生</div>
            <br>
                Open Source, Open Mind, <br/>Open Sight, Open Future!

<!-- 公告栏可使用 HTML、JavaScript，比如可以在此加入第三方统计 js -->
        </div>


        <div class="fn__flex-1 footer__copyright">
            <a class="ft__link" href="https://wuruohui.github.io/archives.html">
                56
                文章
            </a>
           <br>
            <span data-uvstaturl="https://wuruohui.github.io">0</span> <span class="ft-gray">浏览</span>
 <br>
            &copy; 2021
            <a class="ft__link" href="https://wuruohui.github.io">WuRuoHui 的个人博客</a>
            
        </div>
    </div>
</footer>
<script>
  var Label = {
    speech: true,
    servePath: "https://wuruohui.github.io",
    staticServePath: "https://wuruohui.github.io",
    luteAvailable: false,
    hljsStyle: 'github',
    langLabel: "zh_CN",
    version: "4.3.1",
    staticSite: true,
    showCodeBlockLn: false,
    articleId: "1606349708212",
  }
</script>
<script type="text/javascript" src="https://wuruohui.github.io/skins/Pinghsu/js/headroom.min.js"></script>
<script type="text/javascript"
        src="https://wuruohui.github.io/skins/Pinghsu/js/common.min.js?1613894294256"
        charset="utf-8"></script>
<link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/kanbanniang@0.2.10/index.css"/>
<script async src="https://cdn.jsdelivr.net/npm/kanbanniang@0.2.10/index.js"></script>
<div class="solo-kanbanniang">
    <div class="solo-kanbanniang__tip"></div>
    <canvas id="soloKanbanniang" width="280" height="250"></canvas>
    <div class="solo-kanbanniang__tool">
        <svg id="soloKanbanniangHome" viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M32 18.967l-16-12.42-16 12.42v-5.064l16-12.42 16 12.42zM28 18.516v12h-8v-8h-8v8h-8v-12l12-9z"></path>
        </svg>
        <svg id="soloKanbanniangRSS" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M320.364 768q0 45.728-32 77.728t-77.728 32-77.728-32-32-77.728 32-77.728 77.728-32 77.728 32 32 77.728zM612.94 838.272q1.152 16-9.728 27.424-10.272 12-26.848 12h-77.152q-14.272 0-24.576-9.44t-11.424-23.712q-12.576-130.848-105.44-223.712t-223.712-105.44q-14.272-1.152-23.712-11.424t-9.44-24.576V402.24q0-16.576 12-26.848 9.728-9.728 24.576-9.728h2.848q91.424 7.424 174.848 46.016t148 103.712q65.152 64.576 103.712 148t46.016 174.848z m292.576 1.152q1.152 15.424-10.272 26.848-10.272 11.424-26.272 11.424h-81.728q-14.848 0-25.44-10.016t-11.136-24.288q-6.848-122.848-57.728-233.44t-132.288-192-192-132.288-233.44-58.272q-14.272-0.576-24.288-11.136t-10.016-24.864V109.664q0-16 11.424-26.272 10.272-10.272 25.152-10.272h1.728q149.728 7.424 286.56 68.576t243.136 168q106.848 106.272 168 243.136t68.576 286.56z"></path>
        </svg>
        <svg id="soloKanbanniangChat" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M802.42709 96.163153H219.476155c-84.48109 0-154.896836 71.746044-154.896836 157.840888v393.119449c0 86.072331 70.415746 157.819398 154.896836 157.819399h214.038818V925.470963s22.526039 40.168862 64.767096 5.734608c30.965246-25.819039 126.721123-91.828428 171.775248-123.385145h132.369773c84.502579 0 154.896836-83.21526 154.896836-157.839865V251.125481c0-86.094844-70.394257-154.962328-154.896836-154.962328zM301.144176 518.002714c-39.427988 0-70.416769-31.576159-70.416769-71.746044 0-40.168862 30.988782-71.746044 70.416769-71.746044 39.426965 0 70.393233 31.577183 70.393234 71.746044 0 40.169885-30.966269 71.746044-70.393234 71.746044z m208.411657 0c-39.450501 0-70.415746-31.576159-70.415746-71.746044 0-40.168862 30.965246-71.746044 70.415746-71.746044 39.405475 0 70.394257 31.577183 70.394257 71.746044 0 40.169885-30.988782 71.746044-70.394257 71.746044z m211.203236 0c-39.426965 0-70.416769-31.576159-70.416769-71.746044 0-40.168862 30.988782-71.746044 70.416769-71.746044s70.415746 31.577183 70.415746 71.746044c-0.001023 40.169885-30.988782 71.746044-70.415746 71.746044z"></path>
        </svg>
        <svg id="soloKanbanniangChange" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M936.672 193.216l-226.88-64c-8.704-2.528-18.112-1.12-25.824 3.776-7.68 4.864-12.896 12.736-14.432 21.728C655.712 236.928 595.328 288 512 288c-71.424 0-142.464-103.296-163.776-143.104-7.136-13.28-22.528-19.84-37.024-15.68l-224 64C73.472 197.152 64 209.728 64 224v256a31.93 31.93 0 0 0 11.712 24.736c7.392 6.08 17.152 8.512 26.56 6.624L224 487.04V832c0 52.928 43.072 96 96 96h384c52.928 0 96-43.072 96-96V519.04l121.728 24.352c9.44 1.92 19.2-0.544 26.56-6.624C955.68 530.656 960 521.6 960 512V224c0-14.336-9.536-26.912-23.328-30.784zM672 800H352c-17.664 0-32-14.304-32-32s14.336-32 32-32h320c17.696 0 32 14.304 32 32s-14.304 32-32 32z"></path>
        </svg>
        <svg id="soloKanbanniangPhoto" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M898.048 258.048q23.552-1.024 46.592 9.216t40.96 27.136 28.672 39.424 10.752 46.08l0 390.144q0 24.576-10.752 47.104t-28.672 40.448-40.96 28.16-47.616 10.24l-697.344 0q-24.576 0-48.64-10.24t-42.496-27.648-29.696-40.448-11.264-48.64l0-381.952q0-22.528 10.752-45.568t28.672-41.472 39.936-30.208 44.544-11.776l63.488 0 13.312-83.968q3.072-20.48 18.432-32.768t34.816-12.288l456.704 0q19.456 0 34.304 10.752t16.896 34.304l14.336 83.968 54.272 0zM548.864 712.704q40.96 0 77.824-15.872t63.488-42.496 42.496-62.976 15.872-77.312-15.872-77.312-42.496-62.976-63.488-42.496-77.824-15.872-77.312 15.872-63.488 42.496-43.008 62.976-15.872 77.312 15.872 77.312 43.008 62.976 63.488 42.496 77.312 15.872z"></path>
        </svg>
        <svg id="soloKanbanniangGithub" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M1024 524.8c0 114.346667-32.554667 217.216-97.706667 308.565333-65.066667 91.306667-149.162667 154.538667-252.288 189.610667-11.989333 2.304-20.778667 0.682667-26.325333-4.778667a27.605333 27.605333 0 0 1-8.362667-20.48v-144.213333c0-44.16-11.52-76.501333-34.645333-97.024 25.344-2.730667 48.085333-6.826667 68.309333-12.288a268.629333 268.629333 0 0 0 62.72-26.666667 187.434667 187.434667 0 0 0 53.973334-45.44c14.421333-18.005333 26.197333-41.898667 35.328-71.765333 9.088-29.824 13.653333-64.128 13.653333-102.826667 0-55.125333-17.536-102.058667-52.650667-140.8 16.426667-41.429333 14.677333-87.893333-5.333333-139.392-12.458667-4.096-30.464-1.578667-54.016 7.509334a355.328 355.328 0 0 0-61.312 30.08L640 271.274667a462.336 462.336 0 0 0-128-17.749334c-43.989333 0-86.656 5.930667-128 17.749334a589.824 589.824 0 0 0-28.330667-18.432c-11.776-7.253333-30.336-16.042667-55.68-26.325334-25.344-10.24-44.416-13.312-57.301333-9.216-19.584 51.498667-21.12 97.962667-4.693333 139.434667-35.114667 38.698667-52.650667 85.632-52.650667 140.757333 0 38.698667 4.565333 72.874667 13.653333 102.485334 9.130667 29.610667 20.778667 53.546667 34.986667 71.765333 14.250667 18.218667 32.128 33.493333 53.674667 45.781333 21.546667 12.288 42.453333 21.205333 62.677333 26.666667 20.224 5.461333 43.008 9.557333 68.309333 12.288-17.749333 16.384-28.629333 39.850667-32.64 70.4a130.005333 130.005333 0 0 1-29.994666 10.24c-10.666667 2.261333-23.338667 3.413333-37.973334 3.413333-14.72 0-29.269333-4.906667-43.690666-14.677333-14.464-9.813333-26.794667-24.064-36.992-42.709333a109.226667 109.226667 0 0 0-32.341334-35.541334c-13.141333-9.130667-24.106667-14.592-33.024-16.426666l-13.312-2.048c-9.344 0-15.786667 1.024-19.328 3.072-3.584 2.090667-4.693333 4.693333-3.328 7.893333 1.28 3.157333 3.328 6.4 5.973334 9.557333 2.688 3.2 5.546667 5.930667 8.661333 8.192l4.693333 3.413334c9.770667 4.565333 19.413333 13.226667 29.013334 25.984 9.514667 12.757333 16.512 24.362667 20.992 34.858666l6.656 15.701334c5.76 17.322667 15.530667 31.317333 29.312 42.026666 13.781333 10.666667 28.672 17.536 44.672 20.48 16 2.986667 31.445333 4.565333 46.336 4.821334 14.890667 0.213333 27.221333-0.597333 36.992-2.389334l15.36-2.730666c0 17.28 0.085333 37.546667 0.298666 60.8l0.341334 36.906666a27.050667 27.050667 0 0 1-8.661334 20.48c-5.76 5.461333-14.677333 7.082667-26.666666 4.778667-103.125333-35.072-187.221333-98.261333-252.330667-189.610667C32.554667 742.058667 0 639.146667 0 524.8c0-95.232 22.869333-183.04 68.693333-263.466667A516.266667 516.266667 0 0 1 254.976 70.4C333.44 23.466667 419.114667 0 512 0c92.885333 0 178.56 23.466667 256.981333 70.4a516.266667 516.266667 0 0 1 186.368 190.976C1001.130667 341.802667 1024 429.653333 1024 524.842667z"></path>
        </svg>
        <svg id="soloKanbanniangClose" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M517.572566143763 1018.6748601482986C238.26554897656422 1018.6748601482986 11.897910175114305 792.2714997690043 11.897910175114305 513.0002041796496c0-279.3070171671984 226.36763880144977-505.71037754649296 505.6746559686481-505.71037754649296 279.2712955893538 0 505.6746559686481 226.40336037929444 505.6746559686481 505.71037754649296C1023.2472221124112 792.2714997690043 796.8795833109612 1018.6748601482986 517.572566143763 1018.6748601482986zM754.7281214542927 339.25044954334646c13.752807470184345-13.752807470184345 9.680547595895998-40.186775075214015-9.073280772537204-58.94060344364717l-2.143294670678079-2.1075730928334457c-18.7538283684332-18.7538283684332-45.15207439561819-22.861809820566194-58.90488186580257-9.073280772537204l-168.21291007038468 168.24863164822932-180.42968969324974-180.46541127109438c-13.967136937252159-13.967136937252159-40.72259874288353-9.823433907274534-59.72647815622916 9.216167083915742l-2.143294670678079 2.143294670678079c-19.039600991190277 19.003879413345654-23.111860865478626 45.75934121897699-9.180445506071107 59.655035000539876l180.42968969324974 180.46541127109438-176.07165719620428 176.03593561835962c-13.788529048028984 13.824250625873615-9.716269173740633 40.151053497369375 9.073280772537204 58.94060344364717l2.1075730928334457 2.1075730928334457c18.7538283684332 18.7538283684332 45.15207439561819 22.897531398410823 58.90488186580257 9.073280772537204l176.10737877404887-176.10737877404887 170.39192631890742 170.42764789675192c13.967136937252159 13.931415359407513 40.686877165038865 9.85915548511917 59.690756578384516-9.180445506071107l2.1790162485227142-2.1790162485227142c19.039600991190277-18.968157835501014 23.147582443323273-45.72361964113239 9.180445506071107-59.690756578384516l-170.39192631890742-170.42764789675192L754.7281214542927 339.25044954334646z"></path>
        </svg>
    </div>
</div>



<script type="text/javascript">
    Util.addScript('https://wuruohui.github.io/js/page.min.js?1613894294256', 'soloPageScript')
    var page = new Page({
        "commentContentCannotEmptyLabel": "评论不能为空",
        "oId": "1606349708212",
        "blogHost": "https://wuruohui.github.io",
        "randomArticles1Label": "随机阅读：",
        "externalRelevantArticles1Label": "站外相关阅读："
    });
    $(document).ready(function () {
        page.load();
    page.tips.externalRelevantArticlesDisplayCount = "0";
    page.loadRandomArticles('<h3>RECOMMEND POSTS</h3>');
    page.loadRelevantArticles('1606349708212', '<h3>RELEVANT POSTS</h3>');
Skin.initArticle()
    });
</script>

</body>
</html>

<!-- Generated by Latke (https://github.com/88250/latke) in 72ms, 2021/02/21 15:59:55 -->